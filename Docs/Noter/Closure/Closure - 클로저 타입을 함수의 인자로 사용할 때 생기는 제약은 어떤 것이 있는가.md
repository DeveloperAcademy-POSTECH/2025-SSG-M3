
> [!question]  
> GQ. 클로저 타입을 함수의 인자로 사용할 때 생기는 제약은 어떤 것이 있는가

---
### **0. 키워드 개념 정리**

**1) 클로저 (Closure)**
- 이름 없는 **익명 함수**
- 변수처럼 전달 가능한 실행 코드 블록
- **함수 안에서 정의**, **함수에 인자로 전달**, **값으로 반환** 가능
- 주변의 변수/상태를 **캡처**할 수 있음

**2) '클로저 타입을 함수의 인자로 사용'**
- 함수를 호출할 때 특정 동작을 외부에서 넘겨주는 방식
- 예: 버튼 클릭 시 실행할 동작을 클로저로 전달
```swift
func runTask(_ action: () -> Void) {
    action()
}
runTask {
    print("태스크 실행됨")
}
```

**3) @escaping**
- 클로저를 "함수 밖으로 탈출시켜야 할 때" 사용
- 함수 밖으로 탈출?
	- 클로저가 함수 내부에서 나중에 비동기로 실행되거나
	- 함수가 끝난 후까지 살아남아 실행되는 경우
- 예: 네트워크 요청 후 응답 처리
```swift
	func fetchData(completion: @escaping () -> Void) {
    DispatchQueue.global().async {
        // 네트워크 요청 시뮬레이션
        sleep(2)
        print("데이터 받아옴")
        completion() // 나중에 클로저 실행
    }
}
// fetchData() 함수는 completion이라는 클로저를 파라미터로 받음
// 그런데 함수 본문에서 바로 실행하지 않고 DispatchQueue.global.async {} 라는 비동기 큐 안에서 나중에 실행함
// 이때는 클로저가 함수 fetchData()의 스코프를 벗어나서 탈출하게 되므로 @escaping이 필요하다.

// 왜 필요?
// 스위프트 컴파일러는 함수가 끝나면 메모리에서 파라미터를 정리해버림.
// 클로저가 함수 실행 종료 뒤 나중에 실행될 거라면 스위프트는 이 클로저를 힙에 따로 저장해서 계속 유지해야 함.
// 이걸 컴파일러에게 알려주는 키워드가 @escaping

```

**4) autoclosure, rethrows, inout 파라미터 등 제한**
- 클로저는 **스코프, 캡처, 생명주기, 동기/비동기 여부** 등에 따라 사용 제약이 있음


### **1. 개요**

Swift에서 **클로저는 매우 유연하게 사용**되지만, 함수의 인자로 넘길 때는 몇 가지 중요한 제약과 고려사항이 따른다.

이러한 제약은 다음과 같은 이유 때문이다:

- 클로저는 **값처럼 보이지만, 실행 코드이자 상태를 가지는 객체임**
- 캡처한 변수의 생명주기 관리가 필요함
- 비동기 또는 동기 호출 방식에 따라 실행 시점이 달라짐

그래서 함수 안에 클로저를 넣을 때는 **“어떤 시점에 실행되는가?”, “무엇을 참조하고 있는가?”** 등을 명확히 고려해야 한다!

### **2. 주요 제약 정리**
| **제약**                            | **설명**                                              |
| --------------------------------- | --------------------------------------------------- |
| **@escaping 키워드 필요**              | 함수 실행 이후에도 클로저가 살아있을 수 있으면 @escaping을 명시해야 함        |
| **inout 파라미터와 함께 사용 불가**          | 클로저 안에서 inout 파라미터를 직접 캡처하거나 변경할 수 없음               |
| **non-escaping 클로저는 비동기 처리 불가**   | 비동기로 클로저를 실행하려면 반드시 @escaping이어야 함                  |
| **클로저가 캡처한 변수의 생명주기 주의**          | 외부 변수를 참조하면 **retain cycle**이 발생할 수 있음 (특히 self 캡처) |
| **autoclosure는 매개변수가 없는 표현식만 가능** | 클로저로 감싸서 나중에 표현식을 실행하는 기능인데, 복잡한 로직 전달에는 부적합        |

### **3. 대표 상황별 제약 예시**

 **1) 비동기 클로저는 @escaping 필요**
 ```swift
 func request(completion: @escaping () -> Void) {
    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
        completion()
    }
}
```
→ 클로저가 함수 실행 이후에 실행될 예정이므로 @escaping이 필요

  **2) inout 파라미터는 클로저 안에서 사용 불가**
```swift
func perform(_ action: () -> Void) {}

func test(inoutValue: inout Int) {
    // 오류 발생
    // perform {
    //     inoutValue += 1
    // }
}
```
→ `inout 파라미터`\*는 **실행 시점이 명확한 함수 스코프 안에서만** 안전하게 사용 가능

\*`inout` 파라미터
: 값을 함수 안에서 직접 수정할 수 있게 허용하는 키워드
함수가 끝나면 변경 사항이 원래 변수에도 반영된다.
그래서 `&value`처럼 `&`을 붙여 넘겨야 한다.(원본 변수 자체-메모리 주소에 담긴 진짜 변수-를 수정하는 거니까)

왜 클로저 안에서는 사용할 수 없을까?
"클로저의 실행 시점이 함수와 다를 수 있어서"!

함수 호출은 즉시 실행된다.
`inout`은 "지금! 값을 바꾼다"는 걸 보장할 수 있다.
클로저는 그게 안 된다. 함수가 끝난 뒤에 비동기로 실행될 수도 있으니까.

`inout`은 함수 실행 중에만 안전하다.
스위프트의 `inout`은 메모리를 잠깐 빌려와서 직접 값을 바꾸는 구조라서
함수가 끝날 때까지는 메모리를 독점적으로 가지고 있어야 한다.

근데 클로저가 함수 종료 후에 실행되면?
이미 `inoutValue`의 메모리 사용 권한이 사라져있다.
그걸 클로저가 다시 건드리려고 한다? 메모리 접근 오류 발생!

-> 스위프트는 아예 컴파일 타임에 오류로 막아버림.

안전하게 쓰려면?
```swift
func test(inoutValue: inout Int) {
    var temp = inoutValue
    perform {
        temp += 1
        print(temp)
    }
    inoutValue = temp
}
```

**3) 클로저의 캡처로 인한 순환 참조**
```swift
class ViewModel {
    var name = "Noter"
    
    func fetch() {
        someAsyncFunction { [weak self] in
            print(self?.name ?? "nil")
        }
    }
}
// ViewModel ↔ 클로저 
// 서로를 강하게 참조하게 되면 둘 다 메모리에서 해제되지 않음
```
→ self를 캡처할 때 `[weak self]`를 붙이지 않으면 클로저가 self를 강하게 참조함 => 메모리 누수(Retain Cycle) 위험

무슨 말?

먼저 스위프트는 ARC(Automatic Reference Counting)방식으로 메모리를 관리한다.
즉, 어떤 인스턴스가 더 이상 참조되지 않으면 자동으로 메모리에서 해제되는 것.
```swift
var a: ViewModel? = ViewModel() // a가 ViewModel 인스턴스를 참조
a = nil // 더 이상 참조하지 않으므로 ARC가 메모리에서 제거
```

순환 참조는 왜 문제일까?
두 개 이상의 객체가 서로를 강하게 참조하면 ARC가 객체를 메모리에서 해제하지 못해 메모리를 계속 차지하게 된다. 이것이 순환 참조(retain cycle)이고 메모리 누수로 이어지는 것.

클로저도 객체
클로저도 내부적으로 Heap에 저장되는 객체.
-> 클로저가 self를 캡처하면, 즉 참조하면
self는 클로저를 참조하고, 클로저는 다시 self를 참조하게 되어 순환 참조가 생긴다.

그 해결법이 `[weak self]` 또는 `[unowned self]`
```swift
someAsyncFunction { [weak self] in
    print(self?.name ?? "nil")
}
```

`weak self`는 약한 참조(weak reference)를 만들어 클로저가 self를 강하게 잡지 않게 된다.
즉, 클로저는 self가 살아있을 때만 접근하고, 아니라면 그냥 nil을 반환함.  

이러면 메모리 해제 순서를 방해하지 않기 때문에 순환 참조를 피할 수 있다!


### **4. 요약 정리**
|**구분**|**내용**|
|---|---|
|함수 인자로 클로저 전달 시|실행 시점, 캡처 변수, 동기/비동기 여부 고려 필요|
|주요 제약|@escaping 사용 여부, inout과의 충돌, 메모리 캡처 주의|
|대표 상황|비동기 처리, UI 콜백, 네트워크 응답 등에서 자주 사용됨|
|실무 팁|self는 항상 [weak self]로 캡처하는 습관이 좋음


---
### Keyword

- [[클로저 (Closure)]]

### 작성자

#Noter