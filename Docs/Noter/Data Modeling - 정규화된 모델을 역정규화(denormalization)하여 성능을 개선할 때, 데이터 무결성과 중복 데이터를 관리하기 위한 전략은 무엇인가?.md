
> [!question]  
> GQ. 정규화된 모델을 역정규화(denormalization)하여 성능을 개선할 때, 데이터 무결성과 중복 데이터를 관리하기 위한 전략은 무엇인가?

### **0. 키워드 개념 정리**

 **1) 정규화 (Normalization)**

- **데이터 중복을 줄이고, 일관성을 높이기 위한 데이터 구조화 기법**
- 테이블을 작게 나누고 관계로 연결해서 같은 정보가 여러 곳에 중복 저장되지 않도록 설계한다.
- 예: 사용자와 주문을 별도 테이블로 분리하고 userId로 연결함

 **2) 역정규화 (Denormalization)**

- **성능 향상을 위해 일부러 중복을 허용하면서 데이터를 통합하는 설계 방식**
- JOIN 없이도 빠르게 조회할 수 있도록 여러 테이블의 정보를 한 테이블에 합쳐둔다.
- 예: 주문 테이블에 사용자 이름, 이메일을 같이 저장함
  
**3) 데이터 무결성 (Data Integrity)**

- **데이터가 정확하고 일관되게 유지되는 상태**
- 중복되거나 잘못된 데이터가 섞이지 않도록 관리하는 것이 중요    
- 정규화는 무결성을 높이지만 느릴 수 있고, 역정규화는 성능을 높이지만 무결성 관리가 어려워질 수 있음


→ 이제 <span style="color: orange">"정규화된 모델을 역정규화(denormalization)하여 성능을 개선할 때, 데이터 무결성과 중복 데이터를 관리하기 위한 전략은 무엇인가?" </span> 라는 gq을 풀어보자.

데이터를 정규화하면 중복은 줄지만 느려질 수 있다. 그래서 빠르게 읽기 위해 역정규화(일부터 중복을 허용)하는 경우가 많은데, 이렇게 되면 중복된 데이터가 서로 달라지거나, 수정할 때 실수가 생길 수 있다.

**데이터를 빠르게 읽을 수 있게 중복시켰을 때, 그 중복된 데이터들이 서로 어긋나지 않도록 어떻게 잘 관리할 수 있을까? 즉, 성능도 잡고 정확성(무결성)도 지키는 방법은?** 이런 질문이다.

### 1. 개요

정규화는 데이터를 **중복 없이 구조화**해서 저장하는 방식이다. 일반적으로 관계형 데이터베이스(RDB)에서는 정규화를 통해 **데이터 무결성**을 유지하고, **저장공간을 효율적으로 사용**할 수 있다.

하지만 실제 운영 환경에서는 성능 문제가 발생할 수 있다. 예를 들어:

- 여러 테이블을 조인해야만 필요한 정보를 얻을 수 있는 구조 → **조회 성능 저하**
- 반복적인 쿼리, 복잡한 조인 → **응답 시간 느려짐**

이럴 때 도입하는 것이 "역정규화"다.

> **역정규화(Denormalization)**: 성능 향상을 위해 일부 데이터를 중복 저장하거나 테이블을 통합하는 방식

그렇다면 문제는?

- 데이터가 중복되면 → 변경 시 **일관성(무결성)** 유지가 어려워진다.

→ 역정규화는 무조건 좋은 것이 아니며, **트레이드오프를 관리할 전략**이 필요하다.


### 2. 왜 역정규화를 할까?

**2.1 성능 향상**

- 조회 쿼리에서 여러 테이블을 조인하지 않아도 됨 → 쿼리 성능 개선
- 정규화 모델에 비해 응답 속도 빨라짐 (특히 NoSQL에서 자주 사용됨 - JOIN 연산 자체가 없어서.)

**2.2 캐싱\*에 유리**

- 정규화 모델은 조회 시마다 조인이 필요해 캐싱이 어려움
- 역정규화된 결과는 **그대로 캐싱**해서 성능 향상 가능

\* 캐시: 자주 사용하는 데이터를 임시로 저장해두는 공간
**정규화된 구조에선 캐시가 왜 어려울까?**
정규화된 구조에서는 데이터를 쪼개서 보관한다.
예를 들어 블로그 게시글 하나를 보여주려면 다음처럼 조합이 필요하다:

1. Posts 테이블에서 글 정보 조회
2. Users 테이블에서 작성자 정보 JOIN
3. Tags 테이블에서 태그들 JOIN
4. Comments 테이블에서 댓글 리스트 JOIN
  
→ **매번 여러 테이블을 합쳐서 결과를 새로 만들어야** 하는 것.

 **그럼 무슨 문제가 있냐면?**

- 작성자가 이름을 바꾸면?
- 댓글이 새로 달리면?

→ 전체 화면의 결과가 **달라지게 된다.**

**조금만 바뀌어도 캐시가 무의미**해지는 것이다. “어떤 게 바뀌었는지” 캐시가 알 수 없고, 통째로 무효화해야 하기 때문에.

**2.3 단순 쿼리 구성**

- 테이블 구조가 단순해져서 읽기 쿼리를 단순하게 작성할 수 있음

이렇게 역정규화는 특히 **읽기**가 많은 서비스에서 유리하다.
단점은 아래에..

### 3. 문제점: 중복과 무결성 관리

역정규화를 도입하면 다음과 같은 문제가 생긴다:

|문제|설명|
|---|---|
|**중복된 데이터**|동일한 정보가 여러 테이블/문서에 중복되어 저장됨|
|**데이터 무결성 문제**|한 곳만 업데이트될 경우, 다른 곳과 값이 달라질 수 있음|
|**복잡한 업데이트 로직**|수정할 때 모든 중복된 위치를 같이 업데이트해야 함|

### 4. 해결 전략

**4.1 트리거(Trigger)\* 또는 앱 로직을 통한 동기화\****

- DB의 트리거나, 애플리케이션 로직을 통해 **수정 시 동시에 다른 테이블/문서도 함께 수정**
- 예: Firestore에서 Cloud Function을 이용해 중복 필드 자동 업데이트

\* 트리거: DB자체에서 데이터가 바뀌었을 때 자동 실행되는 코드.
Firestore는 NoSQL DB라서 트리거 대신 Cloud Function을 사용한다. 데이터 변경 이벤트가 발생하면 자동으로 함수를 실행해 동기화를 처리해준다.

\* 앱 로직 기반 동기화: 데이터를 업데이트할 때 앱 내부 로직에서 관련 필드도 함께 수정하는 방식.
빠르고 자유도가 높으나 실수로 관련 필드를 빠뜨릴 수 있고, 동시에 여러 곳에서 데이터가 수정될 경우 충돌 가능성이 생긴다는 단점이 있다.

**4.2 중복 데이터 최소화 설계**

- 중복을 허용하되, 정말 자주 조회되거나 변경이 거의 없는 필드만 중복
- 예: `사용자 이름`은 변경 가능성이 낮으므로 중복 저장 가능

**4.3 식별자만 중복하고, 주요 값은 join으로 가져오기**

- 중복 필드를 완전히 복사하지 않고, 참조 ID만 넣어둠 → 필요 시 join/fetch

**4.4 변경 가능성 낮은 데이터만 중복**

- 데이터 변경이 거의 없는 경우(예: 국가명, 카테고리 이름 등)에는 중복 저장 허용

**4.5 주기적인 정합성 검증(batch job)**

- 백그라운드 배치에서 **정기적으로 데이터 정합성 검사** → 이상 발생 시 경고나 수정

### 5. 예시

**정규화된 모델**

```text
posts (postId, userId, content)
users (userId, username)
```

조회할 때:

```sql
SELECT posts.content, users.username
FROM posts
JOIN users ON posts.userId = users.userId
```

**역정규화된 모델**

```text
posts (postId, userId, username, content)
```

조회할 때:

```sql
SELECT content, username FROM posts
```

→ join이 없어져 성능 향상됨

→ 단점: username이 변경되면 posts 테이블의 모든 관련 행도 업데이트해야 함


### 6. 정리

- 역정규화는 성능 개선에 유리하지만, 무결성과 중복이라는 리스크를 동반한다.
- 이 리스크를 줄이기 위해서는 **수정 동기화**, **중복 최소화**, **참조 ID 사용**, **배치 검증** 등의 전략을 함께 도입해야 한다.
- 중요한 것은 "어떤 데이터를 중복할지", "언제 동기화할지", "어떤 수준까지 정합성을 보장할지"에 대한 **명확한 기준**을 갖는 것이다.

---

## Keyword

- [[데이터 모델링 (Data Modeling)]]


#Noter