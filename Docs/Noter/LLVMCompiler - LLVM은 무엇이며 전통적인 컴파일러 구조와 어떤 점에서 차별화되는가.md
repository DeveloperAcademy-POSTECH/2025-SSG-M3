
> [!question]  
> GQ. LLVM은 무엇이며 전통적인 컴파일러 구조와 어떤 점에서 차별화되는가
 
### 0. 키워드 개념 정리

**1) 컴파일러(Compiler)**

- **프로그래밍 언어로 작성된 소스코드를 기계어로 번역**하는 프로그램
- 전통적인 컴파일러는 보통 다음과 같은 **단계적 구조**를 가진다:
    - **프론트엔드**: 소스코드 → 추상구문트리(AST) → 중간 표현(IR)
    - **옵티마이저**: 중간 표현 최적화
    - **백엔드**: IR → 타겟 머신코드 생성

**2) LLVM (Low Level Virtual Machine)**

- **범용 컴파일러 인프라스트럭처** (Compiler Infrastructure)
- 다양한 언어와 플랫폼을 지원하도록 설계된 **모듈화된 컴파일러 프레임워크**
- C/C++, Swift, Rust 등 다양한 언어의 백엔드로 사용됨

**3) IR (Intermediate Representation)**

- 소스 코드와 머신코드 사이의 **중간 코드**
- LLVM은 자체 IR(SSA 기반)을 중심으로 모든 최적화와 코드 생성을 수행함

...
그래서 LLVM 컴파일러가 무엇?
기존에는 언어마다 전용 컴파일러가 따로 있었다.

C -> gcc
Java -> javac
이런 식으로.

그런데 LLVM은 이렇게 쓰인다.

Swift -> LLVM IR -> ARM 코드
Rust -> LLVM IR -> x86 코드
C++ -> LLVM IR -> WebAssembly 코드

즉 LLVM은 여러 언어를 공통된 방식으로 기계어로 바꿔주는 뼈대 역할을 한다.
확장성, 재사용성, 최적화 성능이 뛰어나서 현대 언어 대부분이 사용한다.

우리가 Xcode 내부에서 Swift를 작성하고 빌드하면 실제로는 LLVM이 뒤에서 다 처리해주는 것!


---

### 1. 전통적인 컴파일러 vs LLVM

|항목|전통적인 컴파일러|LLVM|
|---|---|---|
|구조|단일 프로세스로 설계됨|모듈화된 컴포넌트 구조|
|재사용성|언어와 플랫폼에 종속적|다양한 언어/타겟에서 재사용 가능|
|IR 사용|내부 전용 IR (비공개, 최적화 제한적)|공용 SSA 기반 IR (강력한 최적화)|
|확장성|새로운 언어나 플랫폼 지원 어려움|유연한 아키텍처로 쉽게 확장 가능|
|커뮤니티|폐쇄적, 언어별 독립|오픈소스, 다양한 언어 지원|

---

### 2. LLVM의 핵심 구성 요소

**2.1 프론트엔드 (예: Clang)**

- 다양한 언어(C, C++, Swift 등)를 분석하고 LLVM IR로 변환

**2.2 LLVM IR**\*

- SSA 기반의 중간 코드
- 사람도 읽을 수 있는 형태로 디버깅, 최적화에 용이

	\* LLVM IR(Intermediate Representation): LLVM 컴파일러가 사용하는 중간 표현 언어.
	
	고급 언어 코드를 바로 기계어로 바꾸는 게 아니라, 중간 단계로 LLVM IR 이라는 코드로 바꾼다음 이걸 기계어로 변환한다.
	
	왜 중간 표현이 필요할까?
	
	1. ✅ **여러 언어를 한 시스템에서 처리할 수 있음**
	    Swift, Rust, C++ 등 다른 언어라도 전부 LLVM IR로 바꾸면 같은 최적화 및 컴파일 과정을 재사용할 수 있다.
	
	2. ✅ **최적화가 쉬움**
	    LLVM IR은 컴퓨터가 처리하기 좋게 설계돼 있어서, **불필요한 코드 제거, 루프 최적화, 인라이닝** 같은 작업이 훨씬 효과적으로 가능하다.
	
	3. ✅ **다양한 플랫폼 지원**
	    IR까지만 만들면 그다음엔 타겟만 바꿔서 ARM, x86, WebAssembly 등 원하는 플랫폼용 기계어로 바꾸기 쉽다.
	
	어떤 모습일까?
	
	LLVM IR은 어셈블리처럼 생겼지만 좀 더 추상화되어 있다.
	```c
	define i32 @add(i32 %a, i32 %b) {
	entry:
	  %sum = add i32 %a, %b
	  ret i32 %sum
	}
	```
	
	위 코드는 add(a: Int, b: Int) -> Int 같은 함수에 해당.
	
	- i32: 32비트 정수
	- %a, %b: 파라미터
	- add: 더하기 연산
	- ret: 결과 반환

**2.3 옵티마이저**

- IR 수준에서 다양한 최적화 수행
    - Dead Code Elimination
    - Constant Folding
    - Loop Unrolling 등

**2.4 백엔드**

- IR을 실제 머신코드(예: x86, ARM 등)로 변환
- 다양한 타겟 아키텍처에 대한 지원

---

### 3. 왜 LLVM이 중요한가?

**3.1 언어 독립성**

- C, C++, Swift, Rust 등 다양한 언어에서 LLVM을 사용해 컴파일 가능

**3.2 플랫폼 독립성**

- 하나의 IR을 여러 플랫폼(x86, ARM, WebAssembly 등)에서 실행 가능

**3.3 모듈화된 구조**

- 프론트엔드, 옵티마이저, 백엔드를 개별 모듈로 분리 → **유지보수와 확장성 우수**

**3.4 고급 최적화 기능**

- 기존 컴파일러보다 풍부하고 강력한 IR 수준 최적화 제공

**3.5 생태계 확장성**

- Swift, Rust, Julia 등 신생 언어들도 LLVM을 기반으로 컴파일러를 개발함

---

### 4. 예시: Swift와 LLVM

Swift는 자체 프론트엔드만 개발하고, **중간 이후부터는 LLVM을 활용**한다:

```text
Swift 코드
 ↓
Swift 프론트엔드
 ↓
LLVM IR 생성
 ↓
LLVM 옵티마이저
 ↓
LLVM 백엔드
 ↓
기계어 코드(x86, ARM 등)
```

이 구조 덕분에 Swift는 빠르게 여러 플랫폼에서 작동 가능한 언어로 성장할 수 있었음.

---

### 5. 정리

LLVM은 기존의 폐쇄적이고 단일한 컴파일러 설계에서 벗어나, **모듈화, 재사용성, 강력한 IR 기반 최적화**를 제공하는 현대적인 컴파일러 프레임워크이다. 전통적인 컴파일러는 보통 특정 언어와 플랫폼에 종속적이지만, LLVM은 다양한 언어와 플랫폼을 연결하는 **범용 인프라스트럭처**로 자리잡았다.

---

### Keyword

- [[LLVM 컴파일러]]

### 작성자

#Noter