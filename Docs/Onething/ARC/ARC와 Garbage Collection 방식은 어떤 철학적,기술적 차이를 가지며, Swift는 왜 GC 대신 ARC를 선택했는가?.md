> [!question]
>  **ARC와 Garbage Collection 방식은 어떤 철학적/기술적 차이를 가지며, Swift는 왜 GC 대신 ARC를 선택했는가?**

프로그래밍 언어는 **메모리 관리 방식**에 따라 런타임 특성과 성능, 안정성에 큰 차이를 보인다.
대표적인 방식 두 가지는 **ARC(Automatic Reference Counting)와 Garbage Collection(GC)** 이다.
Swift는 이 중 ARC를 선택했다.

## **메모리 관리의 기본 개념**

모든 프로그램은 객체를 생성하고, 일정 시점 이후 더 이상 사용하지 않게 된다.
이제 문제가 생긴다.
**이제 안 쓰는 메모리를 언제, 어떻게 해제할 것인가?**
- 명시적 해제: free() 같은 직접 해제 방식 → 실수 많고 위험
- 자동 관리: 현대 언어는 대부분 **자동 메모리 관리 시스템**을 사용한다.

이제 ARC와 GC는 **자동 관리**를 구현하는 서로 다른 접근법이다. 

---

### ARC(Automatic Reference counting) 의 철학

- 컴파일 타임에 메모리 관리코드를 삽입하는 방식.
- **참조 카운트 변경 시점에 즉시 메모리를 해제**한다.
	- 메모리 사용량이 예측 가능
		- 실행 중 갑작스러운 성능 저하가 없다는 장점을 가짐
		- 게임이나 실시간 시스템에서 중요한 특성이다.
	- 객체를 가리키는 참조(reference)가 0이 되면 바로 메모리에서 해제된다.
- 개발자가 메모리 해제 시점을 어느 정도 예측하고 통제할 수 있게 해준다.
	- `weak`, `unowned` 키워드를 통해 참조 사이클을 방지하고, 정확한 메모리 관리를 할 수 있다.

```swift
class Dog {}
var a: Dog? = Dog()  // 참조 카운트 1
var b = a            // 참조 카운트 2
a = nil              // 참조 카운트 1
b = nil              // 참조 카운트 0 → 즉시 메모리 해제
```

```swift
class Person { 
	let name: String
	init(name: String) { self.name = name }
	deinit { print("\(name) is being deinitialized") }
}

func createPerson() { 
	let person = Person(name: "John") 
	// 여기서 person의 reference count는 1 
	// 함수가 끝나면 reference count가 0이 되어 즉시 해제 
}
```


---
## **Garbage Collection의 철학**

- 런타임의 유연성
	- GC는 런타임에 메모리 상태를 분석하여 사용하지 않은 객체를 찾아내는 방식이다.
		- 이는 더 유연하고 복잡한 메모리 패턴을 처리할 수 있다는 철학을 기반
- 개발자 부담의 최소화
	- GC는 개발자가 메모리 관리에 대해 거의 신경 쓰지 않아도 된다는 철학을 추구한다.
	- **참조 사이클이 자동해결**
```swift
class Parent { 
	Child child; 
} 
class Child { 
	Parent parent; // 순환 참조지만 GC가 자동으로 처리
}

// ARC에서는 문제가 되지만, GC에서는 자동 해결 
Parent p = new Parent();
Child c = new Child(); 
p.child = c; 
c.parent = p; 
p = null; 
c = null; // 두 객체 모두 GC에 의해 수거됨
```
- 복잡한 객체 그래프 처리
	- GC는 **주기적으로 메모리를 스캔**해서, 루트 객체(스택, 전역 변수 등)에세 접근 가능한 모든 객체를 찾는다. 이 과정에서 도달 불가능한 객체들을 식별하고 제거한다.
		- 루트 객체들 → 참조 추적 → 도달 가능한 객체들 마킹 → 미표시 객체(garbage) 제거
	- 복잡한 데이터 구조나 상호 참조가 많은 시스템에서 개발자가 메모리 관리를 거의 신경 쓰지 않아도 되게 해준다.

### 최적화
- 현대 GC는 애플리케이션 전체의 메모리 사용 패턴을 분석하여 최적화한다.
- **세대별 GC (Generational GC)**: 대부분의 객체는 생성 후 빠르게 소멸한다는 "약한 세대 가설"을 기반으로 한다.
	```
	Young Generation (젊은 세대)
	├── Eden Space      ← 새 객체 생성
	├── Survivor 0      ← 첫 번째 GC 생존자
	└── Survivor 1      ← 두 번째 GC 생존자
	
	Old Generation (오래된 세대)
	└── Tenured Space   ← 여러 GC를 거쳐 살아남은 객체들
	```
	- **Young Generation**: 자주 GC 실행 (빠르고 효율적)
	- **Old Generation**: 가끔 GC 실행 (시간이 오래 걸림)

- **증분 GC (Incremental GC)**: 전체 힙을 한 번에 스캔하는 대신, **작은 단위로 나누어 처리**한다.
```
전체 GC: [████████████████████████] (긴 일시정지)
증분 GC: [██][██][██][██][██][██] (짧은 일시정지 여러 번)
```
- **동시 GC (Concurrent GC)**: 애플리케이션 실행과 **동시에 백그라운드에서 GC 작업**을 수행한다.
```
애플리케이션 스레드: [실행][실행][실행][실행]
GC 스레드:          [─────GC 작업─────]
```
    
### 동작 방식
1. 루트 객체(예: 글로벌 변수, 스택 변수)를 기준으로
2. 참조가 닿지 않는 객체를 탐색
3. 닿지 않는 객체는 “garbage”로 간주하여 제거
    
### **장점**
- 개발자는 메모리 해제를 신경 쓰지 않아도 된다
- 순환 참조(circular reference)도 알아서 처리

### 단점
- **예측 불가능한 타이밍**에 GC가 동작함 → 성능 변동
- **스톱 더 월드(Stop-The-World)** 현상: GC 중엔 모든 스레드가 멈추기도 함
- 실시간 UI, 게임, 인터랙티브 앱에서 불리할 수 있음

---

## 기술적 차이점 분석

### 메모리 해제 시점
**ARC**: 참조 카운트가 0이 되는 즉시 해제
- 장점: 예측 가능, 실시간 성능
- 단점: 참조 사이클 문제

**GC**: GC 실행 시점에 일괄 해제
- 장점: 참조 사이클 자동 처리
- 단점: 예측 불가능한 일시정지

### 성능 특성
**ARC의 성능 프로파일**:
```
메모리 사용량
    ↑
100MB │     ╭─╮                    ╭─╮
      │    ╱   ╲                  ╱   ╲
 50MB │   ╱     ╲                ╱     ╲
      │  ╱       ╲              ╱       ╲
  0MB └─╱─────────╲────────────╱─────────╲──→ 시간
            즉시 해제        즉시 해제
```
ARC는 **참조 카운트가 0이 되는 순간** 메모리를 해제한다. 따라서 메모리 사용량이 예측 가능하고 일정한 패턴을 보인다. 메모리 사용량이 톱니바퀴 형태로 올라갔다가 바로 떨어지는 특성을 가진다.

**GC의 성능 프로파일**:

```
메모리 사용량
    ↑
200MB │                   ╭████╮            ╭████╮
      │                  ╱      ╲          ╱      ╲
150MB │                 ╱        ╲        ╱        ╲
      │               ╱           ╲      ╱          ╲
100MB │             ╱              ╲    ╱            ╲
      │           ╱                 ╲  ╱              ╲
 50MB │         ╱                    ╲╱                ╲
      │       ╱                       ╲                 ╲
  0MB └──────╱─────────────────────────╲─────────────────╲─→ 시간
           점진적 증가                  GC 실행           GC 실행
                                  (일시정지 발생)
```
GC는 **메모리가 점진적으로 증가**하다가 임계점에 도달하면 한 번에 대량으로 해제한다. 
이 과정에서 **일시정지(Stop-the-World)** 가 발생하며, 메모리 사용량이 급격히 감소한다.

**핵심 차이점**:
- **ARC**: 메모리 해제 시점이 결정론적이고 예측 가능
- **GC**: 메모리가 누적되다가 임계점에서 일괄 정리

### 메모리 오버헤드

**ARC의 메모리 오버헤드**:
swift
```swift
class MyObject {
    var data: String        // 실제 데이터
    // 컴파일러가 자동으로 추가:
    // - Reference Count: 4-8바이트
    // - 타입 정보: 8바이트
}
```

- **객체별 오버헤드**: 각 객체마다 참조 카운트 저장
- **고정 오버헤드**: 객체 수에 비례하여 선형적으로 증가
- **예측 가능**: 객체 하나당 정확히 얼마나 추가 메모리가 필요한지 알 수 있음

**GC의 메모리 오버헤드**:

```java
// 힙 전체 구조
Heap Memory:
├── Young Generation (전체 힙의 1/3)
│   ├── Eden Space
│   ├── Survivor 0
│   └── Survivor 1
├── Old Generation (전체 힙의 2/3)
└── Permanent Generation (메타데이터)

// 추가 오버헤드:
- 객체 헤더 (마킹, 타입 정보)
- GC 알고리즘용 메타데이터
- 세대 구분을 위한 추가 공간
```
- **가변 오버헤드**: 힙 크기의 20-50%까지 추가 메모리 필요
- **알고리즘 복잡도**: 세대별 GC, 압축 등을 위한 추가 공간
- **동적 할당**: GC 성능을 위해 실제 필요량보다 많은 메모리 확보

**성능 트레이드오프**:
- **ARC**: 낮은 메모리 오버헤드, 하지만 참조 카운트 연산 오버헤드
- **GC**: 높은 메모리 오버헤드, 하지만 일반적인 객체 생성/사용 시 오버헤드 없음

---
## Swift가 ARC를 선택한 이유
### 1. 시스템 프로그래밍 언어로서의 요구사항
Swift는 Objective-C를 대체하면서도 시스템 레벨 프로그래밍이 가능한 언어를 목표로 했다. iOS 같은 제한된 환경에서 **예측 가능한 성능과 메모리 사용량**이 필수적이었다.

### 2. Objective-C와의 호환성
Objective-C는 이미 수동 참조 카운팅을 사용하고 있었다. Swift의 ARC는 이러한 기존 생태계와 자연스럽게 통합될 수 있었다.

### 3. 모바일 환경의 제약
모바일 기기의 **제한된 메모리와 배터리**를 고려할 때, GC의 일시정지나 백그라운드 처리는 사용자 경험을 해칠 수 있다. 터치 반응성이나 애니메이션 같은 실시간 인터랙션에서 GC 일시정지는 치명적이다.

### 4. 언어 설계 철학
Swift는 **"안전하지만 빠른" 언어**를 추구했다. ARC는 메모리 안전성을 보장하면서도 런타임 오버헤드를 최소화하는 선택이었다.

## 각 방식의 한계와 해결책

### ARC의 한계
**참조 사이클 문제**:
swift
```swift
class Parent {
    var child: Child?
}
class Child {
    weak var parent: Parent?  // weak 키워드로 해결
}
```

<u>성능 오버헤드: 참조 카운트 증감 연산이 빈번하게 발생하지만, 컴파일러 최적화로 상당 부분 해결</u>


### GC의 한계
**일시정지 문제**: 최신 GC는 증분 GC, 동시 GC 등으로 일시정지 시간을 줄이고 있다.
**메모리 오버헤드**: 더 효율적인 GC 알고리즘과 압축 기법으로 개선 중

---
## Finding & Synthesis

1. **실시간성 vs 편의성**: ARC는 예측 가능한 성능을 제공하지만 개발자가 참조 사이클을 관리해야 하고, GC는 개발 편의성을 제공하지만 예측 불가능한 일시정지가 발생한다는 근본적인 트레이드오프가 존재한다.
2. **메모리 철학의 차이**: ARC는 "필요한 만큼만 정확히 사용"하는 절약 철학을, GC는 "여유있게 확보해서 효율적으로 관리"하는 최적화 철학을 추구한다.
3. **환경 적응성**: 모바일과 IoT 같은 제약 환경에서는 ARC가, 서버와 데스크톱 같은 자원 여유 환경에서는 GC가 각각의 장점을 극대화할 수 있다.
4. **진화 방향**: 두 방식 모두 단점을 보완하는 방향으로 발전하고 있으며, 미래에는 상황에 따라 적응적으로 메모리 관리 방식을 선택하는 하이브리드 접근법이 등장할 가능성이 높다.

---
## GQ
- GC가 "Stop-the-World" 문제를 어떻게 해결하고 있는가?
- 왜 Swift는 weak/unowned 키워드를 제공하는가?

## Keywords
- [[ARC]]

#Onething 