  
> [!question]
> Swift에서 Optional 타입은 실제로 메모리에 어떻게 저장되고, nil 여부는 어떻게 구분될까?

---

## TL;DR
- Optional은 **열거형(enum)** 으로 정의된 타입이다.
- 메모리에서는 `Optional.some(value)` 또는 `Optional.none` 중 하나로 표현된다.
- 실제 저장 구조는 **"1비트로 nil 여부 + 나머지 공간에 값"**으로 최적화되어 있다.
- Swift 컴파일러는 **불필요한 메모리 낭비 없이 Optional을 처리**하도록 최적화함.

---

## 1. Optional은 그냥 문법이 아니다

Swift에서 Optional은 아래처럼 선언된 **enum 타입**이다:
```swift
enum Optional<Wrapped> {
    case some(Wrapped)
    case none
}
```

*즉, Optional은 **“값이 있을 수도 있고(Some), 없을 수도 있다(None)”는 상태를 명시적으로 표현**하는 타입이다.*

---

#### 그런데 왜 Optional이 그렇게 가벼울까?

"Int는 8바이트인데, 그럼 Int?는 9바이트인가요?"
-> 놀랍게도 **아니다. Int?도 8바이트**다.

---

#### 어떻게 가능할까?

Swift는 이걸 **빈 공간을 활용해서 상태를 숨기는 방식**으로 처리한다.
타입에 따라 세 가지 방식이 있다.

---


**1. Int?같은 기본 값 타입은?

|**개념**|**구현 방식**|
|---|---|
|Int?|**8바이트 내에서 값 + 상태를 함께 저장**|
Swift는 Int 값 중에 **실제로 쓰이지 않는 비트 조합**이 있다
그래서 그 **불가능한 값을 ‘nil’로 예약**해둔다.

즉,
- some(5) → 그냥 5
- none → 특수한 비트값 (예: 모든 비트 0)
 > 결과적으로 Int?도 8바이트만 차지하고, 상태는 안 보이게 “살짝 끼워 넣은” 것이다.


#### 2. String? 같은 참조 타입(Optional Reference)

| **개념**  | **구현 방식**          |
| ------- | ------------------ |
| String? | **포인터(nil은 그냥 0)** |

String은 내부적으로 값을 직접 들고 있는 게 아니라,
**값이 있는 메모리 주소(pointer)** 를 들고 있다.

이때 nil은 그냥 -> 포인터가 0x00000000인 상태.

> 이건 C, Objective-C에서도 흔히 쓰는 방식
> Swift는 이걸 그대로 활용해서 **추가 상태 없이도 nil 표현**이 가능


#### 3. **CustomStruct?** 같은 복잡한 구조체는?
|**개념**|**구현 방식**|
|---|---|
|CustomStruct?|**값 + 상태 비트 or enum tag (필요할 때)**|

Swift는 가능한 경우 Int?처럼 1비트를 숨겨서 쓰지만,
만약 구조체가 너무 복잡해서 숨길 공간이 없다면,
**진짜로 상태 구분을 위한 "enum 태그"를 따로 붙인다.**

> 물론 이건 성능이나 메모리 효율을 위해 **컴파일러가 알아서 최적화**하니까,
> 개발자는 그냥 ?를 쓰기만 하면 됨


- enum 태그는 메모리를 쓴다. 하지만 Swift는 필요할 때만, 똑똑하게 최소한으로 사용한다.

---

### 중요한 이유?
Swift는 Optional이라는 **아주 명확한 개념**을 제공하면서도,
내부적으로는 굉장히 똑똑하게 메모리를 아낀다.

- enum처럼 표현하면서도
- C 언어처럼 **압축적으로 저장**하고
- 성능까지 놓치지 않음

> 이걸 통해 우리는 코드를 더 안전하게 작성할 수 있고,
> 컴파일러는 그걸 빠르고 효율적으로 처리해준다.

---

> Swift의 Optional은 단순한 문법이 아니라,
> **열거형 기반의 안전한 추상화이며**,
> 컴파일러가 **메모리 수준에서 똑똑하게 처리하는 최적화의 결과**입니다.

---
# GQ
- [[Enum - Swift의 enum은 메모리에서 어떻게 동작할까?]]
- [[Optional Chaining - 내부적으로 어떤 순서로 동작할까?]]
- [[nil은 언제 포인터 0으로 처리되고 언제 enum으로 처리될까?]]

---
# 이전 History
## **2. 메모리에서는 어떻게 저장될까?**

### **일반적인 Optional은 이렇게 저장된다:**

- some(value) → 값 + 상태 정보(1비트)
- none → 값은 없고, 상태 정보로 nil임을 표현

### **예:** `Optional<Int>`

- Int는 8바이트
- `Optional<Int>`도 대부분 8바이트
- 이유? Swift는 Int의 불가능한 값을 활용해서 nil 여부를 표현함 (예: 모든 비트가 0인 값은 안 쓰므로 nil로 활용)

즉, **추가로 1바이트 더 쓰지 않아도, 값 + nil 여부를 합쳐서 표현 가능함**

---

## **3. Optional이 열거형인데도 효율적인 이유**

Swift는 enum의 내부 상태를 다음과 같이 최적화함:

| **개념**          | **실제 구현 방식**                       |
| --------------- | ---------------------------------- |
| `Int?`          | 8바이트 내에서 nil 여부 + Int 값 저장         |
| `String?`       | 포인터(nil은 0)                        |
| `CustomStruct?` | 값 + 상태 비트 or enum tag (필요 시 추가 공간) |

예를 들어 `Optional<String>`처럼 Reference Type이면,
nil은 그냥 내부 포인터가 0인 상태로 처리됨.

## **4. Optional Chaining과 nil 병합 연산자도 이 구조 위에서 동작함**

```swift
let name: String? = getName()
let firstLetter = name?.first
```
- 옵셔널 체이닝은 내부적으로 **nil 체크 → 값 접근** 순으로 수행됨
- 이 모든 연산은 Optional이라는 enum의 구조를 기반으로 컴파일 시 처리됨

---
> Optional은 단순한 문법이 아니라 enum 기반의 타입이고,
> Swift는 값과 상태를 같이 담되, **메모리 효율을 최대한 유지하며 처리한다.**




