>[!question]
>[!question]
>GQ1. as? 와 as! 연산자의 차이점은 무엇이고, 각각 언제 사용해야 하는가?

## Description
- Type Casting: 인스턴스의 타입을 확인 하거나, 클래스 계층 구조 내에서 다른 타입으로 취급하고자 할 때 사용하는 기능임
- 컴파일 시점에서는 특정 타입이었지만, 런타임에 더 구체적인 타입이나 다른 타입으로 다뤄야 할 필요가 있을 때 타입 캐스팅이 쓰인다. 
## 주요 기능
+ `as` 연산자는 실제 인스턴스의 타입을 다른 타입으로 변환(캐스팅)합니다. 이 연산자는 크게 세 가지 형태로 나뉩니다: `as`, `as?`, `as!`
### 1. as : 업캐스팅
자식 클래스의 인스턴스를 부모 클래스 타입으로 변환하는 것을 업캐스팅이라 함. 업캐스팅은 항상 성공이 보장되므로 `as` 연산자를 사용
```swift
let myDog: Dog = Dog()
let myAnimal: Animal = myDog as Animal // Dog 타입에서 Animal 타입으로 업캐스팅
```
근데 업캐스팅은 항상 성공이 보장되므로   그냥
```swift
let myAnimal: Animal = Dog()
```
이렇게 타입을 명시해주면 컴파일러가 알아서 처리해주기에  `as` 잘 안씀 

### 2. as? : 옵셔널 다운캐스팅
부모 클래스 타입의 인스턴스를 자식 클래스 타입으로 변환하는 것을 다운캐스팅이라 함. 다운캐스팅은 실패할 가능성이 있으므로 `as?` 로 사용한다. `as?`는 다운캐스팅에 성공하면 해당 타입의 옵셔널 값을 반환하고, 실패하면 `nil`을 반환함. 따라서 옵셔널 바인딩(`if let`)과 함께 사용하는 것이 일반적!!

```swift
let someAnimal: Animal = Dog()

if let specificDog = someAnimal as? Dog {
    print("이 동물은 강아지입니다.") // 이 코드가 실행.
    // 이제 specificDog은 Dog 타입으로 안전하게 사용가능 ~.
} else {
    print("강아지가 아닙니다.")
}
```

### 3. as! : 강제 다운캐스팅
개발자가 타입 변환이 100% 성공할 것이라고 확신할 때 사용하는 연산자임. 만약 다운캐스팅에 실패하면 런타임 오류(크래시)가 발생하므로 사용에 각별한 주의가 필요!!!!!

```swift
let definitelyDog: Animal = Dog()

// 이 코드는 성공하지만, 만약 definitelyDog이 Cat 인스턴스였다면 런타임 오류가 발생해용 앱 중단.
let myRealDog = definitelyDog as! Dog
print("확실히 강아지입니다! 🐾")
```


### as? as! 두가지를 언제 사용해야 하는가

as? - 타입 변환이 실패할 가능성이 조금이라도 있을 때 사용함
1. 다양한 타입이 섞인 배열이나 컬렉션을 다룰 때
```swift
let mixedArray: [Any] = [1, "hello", Dog()]
for item in mixedArray {
    // item이 Dog 타입일 수도, 아닐 수도 있으므로 as?로 안전하게 확인
    if let dog = item as? Dog {
        dog.bark()
    }
}
```
2. API 응답, JSON 파싱 등 외부 데이터를 다룰 때 서버에서 받은 데이터가 항상 내가 예상하는 타입이라는 보장이 없으므로, `as?`를 사용해 안전하게 처리해야 함.

 as! - 타입 변환이 100% 성공할 것이라고 개발자가 확신할 때만 사용해야 함.. 실패하면 앱이 중단되기에 여기서 변환이 실패하는 것은 코드 설계상 심각한 오류이므로 즉시 발견해서 수정해야 한다라는 의미를 가진다고 합니다...
 1. 스토리보드에서 UI 객체를 가져올 때
 2. 커스텀 셀을 재사용할 때
 
## Keywords
+ 파생된 키워드들을 작성

## References
- 참고한 레퍼런스를 작성 (예 : Apple의 공식 문서)

## 작성자
- #Sera 